# =============================================================================
# te_conf.yml (QoS + TE by classes/queues)
# How to use:
# - qos: map logical classes to queue IDs configured on switches (OVS/HTB/etc).
# - te: enable/shape Traffic Engineering behavior and eligible classes.
# - classifiers: first-match rules; higher priority wins; class/queue must exist above.
# =============================================================================

qos: # QoS queue/class configuration
  default_queue: 0          # queue id to use when a rule/class does not set one
  class_queues:             # map logical class -> queue id (must match switch QoS)
    HI-REL: 3
    LOW-LAT: 2
    HI-THRU: 1
    BEST-EFF: 0

te:
  protect_queues: [3, 2]      # Do not move traffic from these queues
  lower_queue_is_higher_priority: false  # false => higher queue id is higher priority
  unknown_queue_behavior: "protect"      # protect | lowest
  managed_classes: ["HI-THRU", "BEST-EFF"] # Classes eligible to move (or rules with te: true)

  # ---------------------------------------------------------------------------
  # TE_QOS_D (te_mode=TE_QOS_D): locks + queue groups (dedication)
  # - If queue_groups is not defined, the controller creates one group per observed queue_id.
  # - You can group several queues together so they share a "home" and dedication.
  TE_QOS_D:
    lock_ttl_s: 300         # seconds (TTL) before a lock expires
    lock_bidirectional: true # if true, lock both directions of a link
    max_moves_per_run: 50   # cookie move limit per execution (phase2). Phase1 ignores this limit.
    queue_groups:           # define priority groups by queue id (ranked by queue id)
      - name: GOLD
        queues: [3]
      - name: SILVER
        queues: [2]
      - name: BRONZE
        queues: [1]
      - name: COPPER
        queues: [0]

classifiers: # first-match rules; highest priority wins; class/queue must exist above
  # ===========================================================================
  # 1) CONSTANT / CONTROL / TELEMETRY IoT => HI-REL (queue 0)
  # ===========================================================================
  # MQTT (TCP 1883/8883)
  - name: "IOT_MQTT"
    class: "HI-REL"
    queue: 3
    priority: 100          # higher number = evaluated first
    stable_l4: true        # keep a stable L4 port match for this rule
    match:
      ip_proto: "tcp"
      l4_any_ports: [1883, 8883]

  # HTTP medical sensors
  - name: "IOT_HTTP_MED"
    class: "HI-REL"
    queue: 3
    priority: 90
    stable_l4: true
    match:
      ip_proto: "tcp"
      l4_any_ports: [5000]
      src_subnets: ["198.51.100.15/32", "203.0.113.10/32"]
      dst_subnets: ["198.51.100.15/32", "203.0.113.10/32"]

  # Industrial WebSocket
  - name: "IOT_WBS_INDUSTRIAL"
    class: "HI-REL"
    queue: 3
    priority: 89
    stable_l4: true
    match:
      ip_proto: "tcp"
      l4_any_ports: [8080] # adjust if you use another port
      src_subnets: ["198.51.100.15/32", "203.0.113.15/32"]
      dst_subnets: ["198.51.100.15/32", "203.0.113.15/32"]

  # CoAP
  - name: "IOT_COAP"
    class: "HI-REL"
    queue: 3
    priority: 85
    stable_l4: true
    match:
      ip_proto: "udp"
      l4_any_ports: [5683, 5684]
      src_subnets: ["198.51.100.13/32", "198.51.100.14/32", "203.0.113.12/32"]
      dst_subnets: ["198.51.100.13/32", "198.51.100.14/32", "203.0.113.12/32"]

  # AMQP
  - name: "IOT_AMQP"
    class: "HI-REL"
    queue: 3
    priority: 84
    stable_l4: true
    match:
      ip_proto: "tcp"
      l4_any_ports: [5672, 5671]
      src_subnets: ["198.51.100.15/32", "203.0.113.14/32"]
      dst_subnets: ["198.51.100.15/32", "203.0.113.14/32"]

  # ===========================================================================
  # 2) INTERACTIVE REAL-TIME (VoIP / VideoCall) => LOW-LAT (queue 1)
  # ===========================================================================
  # RTP VoIP (UDP)
  - name: "REALTIME_RTP_VOIP"
    class: "LOW-LAT"
    queue: 2
    priority: 70
    stable_l4: false
    match:
      ip_proto: "udp"
      src_subnets: ["198.51.100.87/32", "203.0.113.80/32"]
      dst_subnets: ["198.51.100.87/32", "203.0.113.80/32"]

  # RTP VideoCall (UDP)
  - name: "REALTIME_RTP_VIDEOCALL"
    class: "LOW-LAT"
    queue: 2
    priority: 69
    stable_l4: false
    match:
      ip_proto: "udp"
      src_subnets: ["198.51.100.90/32", "203.0.113.86/32"]
      dst_subnets: ["198.51.100.90/32", "203.0.113.86/32"]

  # ===========================================================================
  # 3) HIGH THROUGHPUT (IPTV / VOD / Streaming) => HI-THRU (queue 2)
  # ===========================================================================
  # IPTV RTSP (TCP)
  - name: "STREAM_RTSP"
    class: "HI-THRU"
    queue: 1
    priority: 50
    stable_l4: true
    match:
      ip_proto: "tcp"
      l4_any_ports: [8554, 8000]
      src_subnets: ["198.51.100.80/32", "198.51.100.81/32", "203.0.113.84/32"]
      dst_subnets: ["198.51.100.80/32", "198.51.100.81/32", "203.0.113.84/32"]

  # IPTV HLS (HTTP) - to avoid clashing with VOD HTTP, ideally tie it to IPs
  - name: "STREAM_HLS_IPTV"
    class: "HI-THRU"
    queue: 1
    priority: 49
    stable_l4: true
    match:
      ip_proto: "tcp"
      l4_any_ports: [8888]
      src_subnets: ["198.51.100.81/32", "203.0.113.84/32"]
      dst_subnets: ["198.51.100.81/32", "203.0.113.84/32"]

  # VOD
  - name: "VOD_HTTP"
    class: "HI-THRU"
    queue: 1
    priority: 40
    stable_l4: true
    match:
      ip_proto: "tcp"
      l4_any_ports: [80]
      src_subnets: ["198.51.100.89/32", "203.0.113.85/32", "198.51.100.91/32"]
      dst_subnets: ["198.51.100.89/32", "203.0.113.85/32", "198.51.100.91/32"]

  # ===========================================================================
  # 4) BEST EFFORT / BACKGROUND (FTP + noisy UDP) => BEST-EFF (queue 3)
  # ===========================================================================
  - name: "default"
    class: "BEST-EFF"
    queue: 0
    priority: 0
    match: {}
