# Reporte: links (estado de red por enlaces)
# - Genera:
#   - rep_summary.csv (por repetición)
#   - load_summary.csv (agregado por carga)
#   - global_timeseries_mean.csv (series globales agregadas por rep)
#   - link_timeseries_mean.csv (series por enlace agregadas por rep)
#   - plots/* (heatmaps + snapshot de topología en el peor instante)

report: links

inputs:
  extracted_root: "Prueba3/extracted"
  # Estructura esperada:
  # extracted_root/<controller>/<load>/rep_*/reports/ovs/*.csv
  links_glob: "rep_*/reports/ovs/*.csv"
  required_columns:
    - timestamp
    - src_dpid
    - dst_dpid
    - port_no
    - mbps
    - rx_drop
    - tx_drop
    - total_drop
    - util_pct

# Cómo agregamos/identificamos un "enlace" (para heatmap y snapshot):
# Si tu dataset tiene 1 enlace entre pares de switches, undirected_pair es lo más limpio.
links:
  id_mode: "directed" # directed | directed_port | undirected_pair | undirected_pair_port
  agg:
    util: "max" # max | mean (agrega direcciones/puertos dentro del mismo link_id y timestamp)
    mbps: "sum" # sum | mean | max
    drops: "sum" # sum | max  (sobre total_drop)

time:
  align: "relative"
  resample_s: 1 # rellena segundos faltantes con sample-and-hold
  min_reps_per_t: 2 # solo para filtrar puntos al graficar (si hay pocas reps)
  crop_to_common_time: false # si true, recorta series al mínimo t_rel común entre reps (global y por enlace)

metric_labels:
  util_pct_mean: "Utilización (%)"
  drop_rate_mean: "Pérdida (pps)"
  mbps: "Throughput (Mbps)"

# Warmup: recorta el arranque para evitar picos iniciales.
# Para enlaces, lo detectamos con una métrica global (por defecto mean_util).
warmup:
  mode: "fixed" # auto | fixed | none
  auto:
    metric: "mean_util" # mean_util | p95_util | max_util | total_mbps | sum_drop_rate
    idle_th: 3.0 # umbral (ej: util% promedio > 3%)
    smooth_window_s: 5
    sustain_s: 5
    max_search_s: 120
  fixed:
    seconds: 5
  fallback_if_not_found: 0

# Definición de "peor instante" para snapshot de topología
peak:
  metric: "mean_util" # mean_util | p95_util | max_util | sum_drop_rate

stats:
  confidence:
    enable: true
    level: 0.95
    method: "t"

metrics:
  # qué columnas de resumen se agregan en load_summary
  summary_metrics:
    - mean_util_avg
    - p95_util_avg
    - max_util_peak
    - total_mbps_avg
    - sum_drop_rate_avg
    - drops_total

outputs:
  out_dir: "Prueba3/processed/links"
  csv:
    rep_summary: "rep_summary.csv"
    load_summary: "load_summary.csv"
    global_timeseries_mean: "global_timeseries_mean.csv"
    link_timeseries_mean: "link_timeseries_mean.csv"
    missing: "missing_files.csv"
  plots_dir: "Prueba3/processed/links/plots"

# Topología para el snapshot con NetworkX:
# - positions: tú defines dónde va cada switch (en un plano 2D)
# - edges: lista de enlaces físicos (u, v) y opcionalmente su capacity_mbps para rotular
#
# IMPORTANTE:
# - Los DPIDs aquí son enteros (1..17) que coincidan con src_dpid/dst_dpid de tu CSV.
topology:
  nodes: [1, 2, 5, 7, 9, 10]
  # Layout simétrico y con más separación (núcleo como anillo alrededor de S6)
  positions:
    "6": [0.0, 0.0] # centro

    # Núcleo (anillo simétrico)
    "5": [2.0, 1.2] # noreste
    "7": [3.0, 0.0] # este
    "9": [2.0, -1.2] # sureste
    "10": [-2.0, -1.2] # suroeste
    "1": [-3.0, 0.0] # oeste
    "2": [-2.0, 1.2] # noroeste

  links:
    #- [1, 2, { "capacity_mbps": 250 }]
    #- [1, 10, { "capacity_mbps": 250 }]

    #- [2, 5, { "capacity_mbps": 90 }]
    #- [2, 9, { "capacity_mbps": 90 }]

    #- [10, 5, { "capacity_mbps": 90 }]
    #- [10, 9, { "capacity_mbps": 90 }]
    #- [5, 7, { "capacity_mbps": 250 }]
    #- [7, 9, { "capacity_mbps": 250 }]

    - [1, 2, { "capacity_mbps": 250 }]
    - [1, 10, { "capacity_mbps": 250 }]
    - [1, 5, { "capacity_mbps": 250 }]
    - [1, 9, { "capacity_mbps": 250 }]

    - [2, 7, { "capacity_mbps": 90 }]
    - [10, 7, { "capacity_mbps": 90 }]
    - [5, 7, { "capacity_mbps": 90 }]
    - [9, 7, { "capacity_mbps": 90 }]

plots:
  # Heatmaps para un escenario (1 controlador + 1 carga) — solo uso de enlaces.
  heatmaps:
    enable: true
    select:
      controller: "TE_QOS_C"
      load: "9a"
    apply_warmup_cut: true
    min_reps_per_t: 2
    directed_pair_order: "minmax"
    time_window:
      start_s: 10 # ej: 10
      end_s: 350 # ej: 120
    labels:
      title: "OSPF"
      xlabel: "Tiempo (s)"
      ylabel: "Enlace direccional"
      colorbar: "Utilización (%)"
    threshold:
      enable: false
      value: 80 # marca en rojo celdas con utilización (%) por encima de este valor

  # Snapshot de topología en el peor instante (por carga) para 1 controlador
  topology_snapshot_peak:
    enable: false
    controller: "Prueba"
    loads: "all" # "all" o lista: ["1a","2a"]
    edge_agg: "max" # max | mean (si hay 2 direcciones por enlace)
    edge_label_pos: 0.45 # posición de las etiquetas en el enlace (0=inicio, 1=fin)
    time_override_s: null # si se define, usa este segundo en vez del pico
    labels:
      title: "Topología @ pico (ctrl={controller}, load={load}, t={t_peak}s)"
